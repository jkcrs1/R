---
title: "Evaluacion 1"
author: "Jorge Cáceres Barrales"
date: "2024-06-18"
output:
  pdf_document: default
  html_document: default
---

# Objetivo de Investigación

Analizar los datos de permisos de circulación vehicular en Calbuco para identificar patrones y tendencias, y proponer mejoras en la gestión de permisos.

# Introducción

## Descripción del Conjunto de Datos

El conjunto de datos seleccionado para este análisis proviene de los registros de permisos de circulación en la Municipalidad de Calbuco. Este conjunto de datos contiene información detallada sobre vehículos y sus permisos de circulación, incluyendo variables como el tipo de vehículo, año de fabricación, marca, modelo, color, tipo de combustible, y valor del permiso, entre otros.

## Objetivos del Análisis

El objetivo principal de este análisis es investigar y comprender los patrones y tendencias en los permisos de circulación vehicular en Calbuco. Específicamente, se busca:

```         
1.  Identificar las características más comunes de los vehículos que obtienen permisos de circulación.
2.  Analizar la distribución temporal de la obtención de permisos.
3.  Explorar posibles relaciones entre las características de los vehículos y el costo del permiso.
4.  Realizar un modelo que permita estimar la cantidad de pagos que se recibiran en un periodo de tiempo.
```

# Procesamiento de Datos

El preprocesamiento de datos es un paso crucial para garantizar que los datos estén limpios y listos para el análisis. A continuación, se detallan los pasos tomados para limpiar y preparar los datos

## Carga Librerias

```{r}
# Cargar librerías necesarias
library(dplyr)
library(stringr)
library(caret)
library(corrplot)
library(xgboost)
library(factoextra)
library(kableExtra)
library(summarytools)
library(httr)
library(zoo)
library(ggcorrplot)
library(lubridate)
library(gridExtra)
library(grid)

```

## Cargas funciones y base de datos

```{r}
# Enlace raw al archivo de funciones en GitHub
source("https://raw.githubusercontent.com/jkcrs1/R/main/funciones.R")

# Permisos circulación  pagados en la municipalidad de calbuco
url3 <- "https://github.com/jkcrs1/R/raw/main/permiso_circulacion_calbuco.csv"

# Prueba con diferentes codificaciones
permiso <- read.csv(url3, sep = ";", fileEncoding = "ISO-8859-1")

```

## Tipos de Variables

Utilizando el paquete summarytools, se genera un resumen detallado de todas las variables del dataframe. Este informe incluye estadísticas descriptivas, frecuencias, gráficos de barras para variables categóricas y otras visualizaciones útiles para el análisis de datos.

```{r}
# Obtener un resumen de los datos utilizando summarytools y renderizar en HTML
dfSummary(permiso) %>%
  print(method = 'render')
```

## Normalización de las Variables

Se procede a normalizar y limpiar el conjunto de datos, asegurando que las variables estén en el formato correcto y que los valores nulos se manejen adecuadamente.

```{r}
# Convertir permiso a data.frame (por si no lo es)
permiso <- data.frame(permiso)

# Cambio de nombres de columnas: reemplazar puntos por guiones bajos y convertir a minúsculas
colnames(permiso) <- colnames(permiso) %>% str_replace_all("\\.", "_") %>% tolower()

# Mapas de recodificación
tipo_vehiculo_mapeo <- c(
  "AMBULANCIA" = "AMBULANCIA", "AUTOMOVIL" = "AUTOMOVIL", "BUS" = "BUS",
  "Cabriolet" = "AUTOMOVIL", "CAMION" = "CAMION", "CAMIONETA" = "CAMIONETA",
  "CARRO ARRASTRE A" = "REMOLQUE", "CARRO BOMBA" = "CARRO BOMBA",
  "CASA RODANTE" = "CASA RODANTE", "Comercial" = "COMERCIAL", "CUATRIMOTO" = "CUATRIMOTO",
  "FURGON" = "FURGON", "GRUA" = "MAQUINA PESADA", "Hatchback" = "AUTOMOVIL",
  "JEEP" = "AUTOMOVIL", "MAQUINA INDUSTRIAL" = "MAQUINA INDUSTRIAL",
  "MINIBUS" = "MINIBUS", "MINIBUS ESCOLAR" = "MINIBUS", "MINIBUS PARTICULAR" = "MINIBUS",
  "MINIBUS PRIVADO" = "MINIBUS", "MINIBUS TURISMO" = "MINIBUS", "MOTO" = "MOTOCICLETA",
  "MOTOCICLETA" = "MOTOCICLETA", "OTROS" = "OTROS", "REMOLQUE A" = "REMOLQUE",
  "REMOLQUE B" = "REMOLQUE", "RETROEXCAVADORA" = "MAQUINA PESADA", "Sedan" = "AUTOMOVIL",
  "SEMI REMOLQUE" = "REMOLQUE", "STATION WAGON" = "AUTOMOVIL", "SUV" = "SUV",
  "TAXI EJECUTIVO" = "TAXI", "TAXI BASICO" = "TAXI", "TAXI COLECTIVO" = "TAXI",
  "TRACTOCAMION" = "CAMION", "TRACTOR" = "TRACTOR", "VAN" = "VAN"
)

tipo_combustible_mapeo <- c(
  "Benc" = "Bencina", "Dies" = "Diesel", "NULL" = "NULL",
  "DUAL" = "Hibrido", "Hibr" = "Hibrido", "Elec" = "Electrico"
)

transmision_mapeo <- c(
  "Mec" = "Mecanica", "Aut" = "Automatica", "NULL" = "NULL",
  "CVT" = "Automatica", "DCT" = "Automatica"
)

# Mostrar la cantidad de registros iniciales
cat("La cantidad de registros:", nrow(permiso), "\n")

# Aplicar todas las transformaciones y normalizaciones
permiso <- permiso %>%
  mutate(
    # Recodificar las variables categóricas
    tipo_vehiculo = recode(tipo_vehiculo, !!!tipo_vehiculo_mapeo),
    tipo_combustible = recode(tipo_combustible, !!!tipo_combustible_mapeo),
    transmision = recode(transmision, !!!transmision_mapeo),
    
    # Reemplazar nulos en todas las variables
    across(everything(), reemplazar_nulos),
    
    # Convertir a título en variables específicas
    across(c(municipalidad, grupo_vehiculo, placa, digito, codigo_sii,
             forma_pago, tipo_vehiculo, marca, modelo, color,
             transmision, tipo_combustible, equipamiento), str_to_title),
    
    # Quitar las "," y "." de los campos de valores 
    across(c(valor_neto, valor_ipc, valor_multa, valor_pagado), 
                ~ as.numeric(gsub("[,\\.]", "", .))),
    
    # Convertir tipos de datos
    ano_vehiculo = as.integer(ano_vehiculo),
    fecha_pago = as.Date(fecha_pago, format = "%d-%m-%y"),
    ano_pago = as.integer(year(fecha_pago)),
    mes = month(fecha_pago, label = TRUE),
    mes_pago = as.integer(month(fecha_pago)),
    
    # Crear la variable Ano_Mes_Pago
    ano_mes_pago = paste(sprintf("%02d", mes_pago), substr(ano_pago, 3, 4), sep = "-")
  ) %>%
  # Filtrar y eliminar duplicados
  filter(!is.na(valor_pagado) & !is.na(fecha_pago) & valor_pagado > 0) %>%
  distinct()

# Mostrar la cantidad de registros válidos
cat("La cantidad de registros válidos:", nrow(permiso), "\n")


```

## Traformación de variables categoricas a Factor

Para asegurar un análisis e interpretación adecuados de los datos, las variables categóricas se transforman a factores.

```{r}

# Transformar las variables a factor con los niveles definidos
permiso <- permiso %>%
  mutate(across(where(is.character), as.factor),
         fecha = as.Date(paste(ano_pago, mes_pago, "01", sep = "-"), format = "%Y-%m-%d"),
         ano_mes_pago = paste(sprintf("%02d", mes_pago), substr(ano_pago, 3, 4), sep = "-")) %>%
  arrange(fecha) %>%
  mutate(ano_mes_pago = factor(ano_mes_pago, levels = unique(ano_mes_pago))) %>%
  select(-fecha)


```

# Análisis Exploratorio de Datos (EDA)

## Seleccionar variables relevantes

```{r}
permiso_relevante <- permiso %>%
  select(grupo_vehiculo, ano_vehiculo, tipo_de_pago, fecha_pago, ano_pago, mes, mes_pago, ano_mes_pago, valor_neto, valor_ipc, valor_multa, valor_pagado, forma_pago, tipo_vehiculo, marca)
```

## Muestreo

Para asegurar una representación adecuada de cada grupo, realizaremos un muestreo estratificado de los datos. Este proceso garantiza que cada estrato (grupo) esté proporcionalmente representado en la muestra.

```{r}

# Calcular la muestra aleatoria según Desviación Estándar
cant <- nrow(permiso_relevante)
sd <- sd(permiso_relevante$valor_pagado)
n <- tam.muestra(alfa = 0.05, epsilon = 1200, s = sd, N = cant)
set.seed(2)
cant <- sample(nrow(permiso_relevante), n)
permiso_muestra <- permiso_relevante[cant, ]

cat("La cantidad de registros de muestra es:", nrow(permiso_muestra))
```

### Distribucion de Pagos por Año y Meses

```{r}

# Preparar los datos para el gráfico de área
area_data <- permiso_muestra %>%
  group_by(ano_pago, mes) %>%
  summarise(count = n(), .groups = 'drop')

grafico1 <- grafico_histograma(permiso_muestra, "ano_pago")
grafico2 <- grafico_area(area_data, "mes", "count", "ano_pago")

mostrar_graficos(grafico1, grafico2, ncol = 2)

```
La distribución general muestra una tendencia creciente en la cantidad de pagos de un año a otro.
Cabe destacar que por la pandimia, no se realizaron pagos de permisos de circulación durante los años 2020 - 2021.

Como era de esperar, existe  un fuerte patrón estacional en los pagos de permisos de circulación, con la mayoría de los pagos concentrados en los primeros meses del año, particularmente en marzo y abril.

### Variable: Grupo Vehiculo.

```{r}

# Crear gráficos individuales
grafico1 <- grafico_anillo(permiso_muestra,"grupo_vehiculo")
grafico2 <- grafico_barras(permiso_muestra,"tipo_vehiculo")

# Mostrar los gráficos juntos
mostrar_graficos(grafico1, grafico2, ncol = 2)


```




### Valor Pago por Categoria 

```{r}
vehiculo_liviano_dataset <- permiso_muestra %>% filter(`grupo_vehiculo` == "Vehiculo Liviano")
transporte_publico_dataset <- permiso_muestra %>% filter(`grupo_vehiculo` == "Transporte Publico")
carga_dataset <- permiso_muestra %>% filter(`grupo_vehiculo` == "Carga")


# Crear gráficos individuales
grafico1 <- grafico_boxplot(vehiculo_liviano_dataset, "valor_pagado","Vehiculo Liviano")
grafico2 <- grafico_boxplot(transporte_publico_dataset, "valor_pagado","Transporte Publico")
grafico3 <- grafico_boxplot(carga_dataset, "valor_pagado","Carga")



# Mostrar los gráficos juntos
mostrar_graficos(grafico1, grafico2,grafico3, ncol = 3)



```

### BoxPlot por tipo de Vehiculo

```{r}

grafico1 <- grafico_barras(vehiculo_liviano_dataset,"tipo_vehiculo")
grafico2 <- grafico_boxplot_dos_var(vehiculo_liviano_dataset, "tipo_vehiculo","valor_pagado")



# Mostrar los gráficos juntos
mostrar_graficos(grafico1, grafico2, ncol = 2)



```
## Selecionar Dataset de Automoviles y Camionetas

```{r}
vehiculo_dataset <- vehiculo_liviano_dataset %>% 
  filter(tipo_vehiculo == "Automovil" | tipo_vehiculo == "Camioneta")

grafico_anillo(vehiculo_dataset,"tipo_vehiculo")

```


## Tratamiento de Outliers

```{r}

automovil_dataset <- vehiculo_liviano_dataset %>% 
  filter(tipo_vehiculo == "Automovil")

camioneta_dataset <- vehiculo_liviano_dataset %>% 
  filter(tipo_vehiculo == "Camioneta")

resultado1 <- eliminar_outliers(automovil_dataset, "valor_pagado")
resultado2 <- eliminar_outliers(camioneta_dataset, "valor_pagado")

dataset_sin_outliers1 <- resultado1$dataset_sin_outliers
dataset_sin_outliers2 <- resultado2$dataset_sin_outliers


vehiculo_sin_outliers <- bind_rows(dataset_sin_outliers1, dataset_sin_outliers2)



cat("Número de registros originales:", nrow(vehiculo_dataset), "\n")
cat("Número de registros sin outliers:", nrow(vehiculo_sin_outliers), "\n")

vehiculo_dataset<- vehiculo_sin_outliers
```

## Boxplot por tipo de vehiculo

```{r}
automovil_dataset <- vehiculo_dataset %>% filter(`tipo_vehiculo` == "Automovil")
camioneta_dataset <- vehiculo_dataset %>% filter(`tipo_vehiculo` == "Camioneta")

# Crear gráficos individuales
grafico1 <- grafico_boxplot(automovil_dataset, "valor_pagado","Automovil")
grafico2 <- grafico_boxplot(camioneta_dataset, "valor_pagado","Camioneta")



# Mostrar los gráficos juntos
mostrar_graficos(grafico1, grafico2, ncol = 2)
```


## Matriz de correlacion

```{r}
# Crear gráficos individuales
grafico1 <- grafico_matriz_correlacion( vehiculo_dataset)
grafico2 <- grafico_dispersion(vehiculo_dataset, "ano_vehiculo","valor_pagado")

# Mostrar los gráficos juntos
mostrar_graficos(grafico1, grafico2, ncol = 2)


```

## Distribucion de Pagos en Grupos de Vehiculos por Meses Relativos

```{r}
# Filtrar y transformar los datos

vehiculo_dataset <- vehiculo_dataset %>%
  arrange(fecha_pago) %>%
  group_by(tipo_vehiculo) %>%
  mutate(
    fecha_relativa = as.yearmon(fecha_pago),
    mes_relativo = as.integer((min(fecha_relativa) - fecha_relativa) * 12)*-1
  ) %>%
  ungroup()

# Resumir los datos por mes relativo y grupo de vehículo
pagos_por_mes_relativo <- vehiculo_dataset %>%
  group_by(tipo_vehiculo, mes_relativo) %>%
  summarise(Cantidad_Pagos = n(), .groups = 'drop')

grafico_lineas(pagos_por_mes_relativo, "mes_relativo", "Cantidad_Pagos", "tipo_vehiculo")

```

## Valores Nulos y reemplazar por la Mediana

En caso que se encuentren valores, se reemplazan por el valor de la mediana de cada variable.

```{r}
#Imputar valores nulos por la mediana
vehiculo_dataset <- vehiculo_dataset %>%
  mutate(across(everything(), reemplazar_por_mediana))
```

## Descripcion de Variables normalizadas

```{r}
# Obtener un resumen de los datos utilizando summarytools y renderizar en HTML
dfSummary(vehiculo_dataset) %>%
  print(method = 'render')
```

# 4. Modelado de Datos

Aplicación de técnicas de modelado de datos y algoritmos de aprendizaje automático para estimar la cantidad de permisos que se pagarán en los próximos 6 meses por grupo y tipo de vehículo.

## Técnicas y Algoritmos

### 1. Selección del Modelo

Para este análisis, seleccionaremos el modelo XGBoost, que es un algoritmo de boosting que combina múltiples árboles de decisión para mejorar la precisión y el rendimiento del modelo.

### 2. Entrenamiento y Evaluación

### Seleccionar los datos

```{r}

# Configurar semilla para reproducibilidad
set.seed(123)

# Filtrar los datos hasta el año 2018
dataset_modelo <- vehiculo_dataset %>%
  filter(ano_pago <= 2018)

# Definir el tamaño de la muestra por cada categoría de tipo_vehiculo
tamano_muestra <- min(dataset_modelo %>% count(tipo_vehiculo) %>% pull(n))

# Muestreo estratificado para asegurar la misma cantidad de datos por categoría
dataset_modelo <- dataset_modelo %>%
  group_by(tipo_vehiculo) %>%
  sample_n(tamano_muestra) %>%
  ungroup()

grafico_torta(dataset_modelo, "tipo_vehiculo")


```

### Seleccionar Datos

```{r}

# Calcular el mes relativo
dataset_modelo <- dataset_modelo %>%
  arrange(fecha_pago) %>%
  group_by(tipo_vehiculo) %>%
  mutate(
    fecha_relativa = as.yearmon(fecha_pago),
    mes_relativo = as.integer((min(fecha_relativa) - fecha_relativa) * 12)*-1
  ) %>%
  ungroup()

# Crear la variable de cantidad de permisos por grupo de vehículo
cantidad_permisos <- dataset_modelo %>%
  group_by(tipo_vehiculo, mes_relativo) %>%
  summarise(cantidad_permisos = n(), .groups = 'drop')

# Preparar datos con todas las variables
datos_completos <- dataset_modelo %>%
  left_join(cantidad_permisos, by = c("tipo_vehiculo", "mes_relativo"))

# Convertir variables categóricas a factores
datos_completos <- datos_completos %>%
  mutate_if(is.character, as.factor)

# Dividir los datos en conjuntos de entrenamiento (80%) y prueba (20%)
set.seed(1234)
trainIndex <- createDataPartition(datos_completos$cantidad_permisos, p = .8, 
                                  list = FALSE, 
                                  times = 1)
permisoTrain <- datos_completos[trainIndex,]
permisoTest  <- datos_completos[-trainIndex,]

# Asegurar que los niveles de las variables categóricas sean consistentes entre entrenamiento y prueba
permisoTest <- permisoTest %>%
  mutate(across(where(is.factor), ~ factor(.x, levels = levels(permisoTrain[[cur_column()]]))))

# Convertir variables categóricas a indicadores binarios (dummies)
permisoTrain_matrix <- model.matrix(~ . - 1, data = permisoTrain %>% select(-cantidad_permisos))
permisoTest_matrix <- model.matrix(~ . - 1, data = permisoTest %>% select(-cantidad_permisos))

# Crear DMatrix para XGBoost
dtrain_cantidad <- xgb.DMatrix(data = permisoTrain_matrix, label = permisoTrain$cantidad_permisos)
dtest_cantidad <- xgb.DMatrix(data = permisoTest_matrix, label = permisoTest$cantidad_permisos)

# Definir parámetros para el modelo XGBoost
params <- list(booster = "gbtree", objective = "reg:squarederror", eta = 0.3, max_depth = 6)

# Entrenar el modelo XGBoost
modelo_xgb_cantidad <- xgb.train(params, dtrain_cantidad, nrounds = 100)

# Evaluar el modelo
pred_xgb_cantidad <- predict(modelo_xgb_cantidad, dtest_cantidad)
rmse_xgb_cantidad <- RMSE(pred_xgb_cantidad, permisoTest$cantidad_permisos)
rsq_xgb_cantidad <- R2(pred_xgb_cantidad, permisoTest$cantidad_permisos)

# Mostrar resultados del modelo
resultados_cantidad <- tibble(
  Modelo = "XGBoost",
  RMSE = rmse_xgb_cantidad,
  R2 = rsq_xgb_cantidad
)

print(resultados_cantidad)


```

## 5. Interpretación de Resultados

Discusión de los Resultados del Análisis:

• Interpretación de los coeficientes del modelo de regresión. • Identificación de las variables más influyentes. • Recomendaciones basadas en los hallazgos del análisis.
