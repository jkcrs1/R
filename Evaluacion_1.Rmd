---
title: "Evaluacion 1"
author: "Jorge Cáceres Barrales"
date: "2024-06-18"
output:
  pdf_document: default
  html_document: default
---

# Objetivo de Investigación

Analizar los datos de permisos de circulación vehicular en Calbuco para identificar patrones y tendencias, y proponer mejoras en la gestión de permisos.

# Introducción

## Descripción del Conjunto de Datos

l conjunto de datos proviene de los registros de permisos de circulación de la Municipalidad de Calbuco y contiene información detallada sobre vehículos y sus permisos de circulación, incluyendo variables como tipo de vehículo, año de fabricación, marca, modelo, color, tipo de combustible, y valor del permiso.

## Objetivos del Análisis

El objetivo principal es investigar y comprender los patrones y tendencias en los permisos de circulación vehicular en Calbuco. Específicamente, se busca:

Identificar las características más comunes de los vehículos que obtienen permisos de circulación.
Analizar la distribución temporal de la obtención de permisos.
Explorar posibles relaciones entre las características de los vehículos y el costo del permiso.
Realizar un modelo que permita estimar la cantidad de pagos que se recibirán en un periodo de tiempo.

# Procesamiento de Datos

El preprocesamiento de datos es un paso crucial para garantizar que los datos estén limpios y listos para el análisis. A continuación, se detallan los pasos tomados para limpiar y preparar los datos

## Carga Librerias

Se cargan las librerías necesarias para la manipulación de datos, visualización y modelado, como dplyr, stringr, caret, corrplot, xgboost, entre otras.
```{r}
# Cargar librerías necesarias
library(dplyr)
library(stringr)
library(caret)
library(corrplot)
library(xgboost)
library(factoextra)
library(kableExtra)
library(summarytools)
library(httr)
library(zoo)
library(ggcorrplot)
library(lubridate)
library(gridExtra)
library(grid)
library(rlang)

```

## Cargas funciones y base de datos
Se cargan funciones específicas desde un archivo de GitHub y los datos de permisos de circulación desde un CSV en GitHub.
```{r}
# Enlace raw al archivo de funciones en GitHub
source("https://raw.githubusercontent.com/jkcrs1/R/main/funciones.R")

# Permisos circulación  pagados en la municipalidad de calbuco
url3 <- "https://github.com/jkcrs1/R/raw/main/permiso_circulacion_calbuco.csv"

# Prueba con diferentes codificaciones
permiso <- read.csv(url3, sep = ";", fileEncoding = "ISO-8859-1")

```

## Tipos de Variables

Se utiliza el paquete summarytools para generar un resumen detallado de las variables del dataframe.

```{r}
# Obtener un resumen de los datos utilizando summarytools y renderizar en HTML
dfSummary(permiso) %>%
  print(method = 'render')
```

## Normalización de las Variables

Se normalizan y limpian las variables del conjunto de datos, recodificando variables categóricas, reemplazando valores nulos y transformando datos según sea necesario.

```{r}
# Convertir permiso a data.frame (por si no lo es)
permiso <- data.frame(permiso)

# Cambio de nombres de columnas: reemplazar puntos por guiones bajos y convertir a minúsculas
colnames(permiso) <- colnames(permiso) %>% str_replace_all("\\.", "_") %>% tolower()

# Mapas de recodificación
tipo_vehiculo_mapeo <- c(
  "AMBULANCIA" = "AMBULANCIA", "AUTOMOVIL" = "AUTOMOVIL", "BUS" = "BUS",
  "Cabriolet" = "AUTOMOVIL", "CAMION" = "CAMION", "CAMIONETA" = "CAMIONETA",
  "CARRO ARRASTRE A" = "REMOLQUE", "CARRO BOMBA" = "CARRO BOMBA",
  "CASA RODANTE" = "CASA RODANTE", "Comercial" = "COMERCIAL", "CUATRIMOTO" = "CUATRIMOTO",
  "FURGON" = "FURGON", "GRUA" = "MAQUINA PESADA", "Hatchback" = "AUTOMOVIL",
  "JEEP" = "AUTOMOVIL", "MAQUINA INDUSTRIAL" = "MAQUINA INDUSTRIAL",
  "MINIBUS" = "MINIBUS", "MINIBUS ESCOLAR" = "MINIBUS", "MINIBUS PARTICULAR" = "MINIBUS",
  "MINIBUS PRIVADO" = "MINIBUS", "MINIBUS TURISMO" = "MINIBUS", "MOTO" = "MOTOCICLETA",
  "MOTOCICLETA" = "MOTOCICLETA", "OTROS" = "OTROS", "REMOLQUE A" = "REMOLQUE",
  "REMOLQUE B" = "REMOLQUE", "RETROEXCAVADORA" = "MAQUINA PESADA", "Sedan" = "AUTOMOVIL",
  "SEMI REMOLQUE" = "REMOLQUE", "STATION WAGON" = "AUTOMOVIL", "SUV" = "SUV",
  "TAXI EJECUTIVO" = "TAXI", "TAXI BASICO" = "TAXI", "TAXI COLECTIVO" = "TAXI",
  "TRACTOCAMION" = "CAMION", "TRACTOR" = "TRACTOR", "VAN" = "VAN"
)

tipo_combustible_mapeo <- c(
  "Benc" = "Bencina", "Dies" = "Diesel", "NULL" = "NULL",
  "DUAL" = "Hibrido", "Hibr" = "Hibrido", "Elec" = "Electrico"
)

transmision_mapeo <- c(
  "Mec" = "Mecanica", "Aut" = "Automatica", "NULL" = "NULL",
  "CVT" = "Automatica", "DCT" = "Automatica"
)

# Mostrar la cantidad de registros iniciales
cat("La cantidad de registros:", nrow(permiso), "\n")

# Aplicar todas las transformaciones y normalizaciones
permiso <- permiso %>%
  mutate(
    # Recodificar las variables categóricas
    tipo_vehiculo = recode(tipo_vehiculo, !!!tipo_vehiculo_mapeo),
    tipo_combustible = recode(tipo_combustible, !!!tipo_combustible_mapeo),
    transmision = recode(transmision, !!!transmision_mapeo),
    
    # Reemplazar nulos en todas las variables
    across(everything(), reemplazar_nulos),
    
    # Convertir a título en variables específicas
    across(c(municipalidad, grupo_vehiculo, placa, digito, codigo_sii,
             forma_pago, tipo_vehiculo, marca, modelo, color,
             transmision, tipo_combustible, equipamiento), str_to_title),
    
    # Quitar las "," y "." de los campos de valores 
    across(c(valor_neto, valor_ipc, valor_multa, valor_pagado), 
                ~ as.numeric(gsub("[,\\.]", "", .))),
    
    # Convertir tipos de datos
    ano_vehiculo = as.integer(ano_vehiculo),
    fecha_pago = as.Date(fecha_pago, format = "%d-%m-%y"),
    ano_pago = as.integer(year(fecha_pago)),
    mes = month(fecha_pago, label = TRUE),
    mes_pago = as.integer(month(fecha_pago)),
    
    # Crear la variable Ano_Mes_Pago
    ano_mes_pago = paste(sprintf("%02d", mes_pago), substr(ano_pago, 3, 4), sep = "-")
  ) %>%
  # Filtrar y eliminar duplicados
  filter(!is.na(valor_pagado) & !is.na(fecha_pago) & valor_pagado > 0) %>%
  distinct()

# Mostrar la cantidad de registros válidos
cat("La cantidad de registros válidos:", nrow(permiso), "\n")


```

## Traformación de variables categoricas a Factor

Las variables categóricas se transforman a factores para asegurar un análisis adecuado.

```{r}

# Transformar las variables a factor con los niveles definidos
permiso <- permiso %>%
  mutate(across(where(is.character), as.factor),
         fecha = as.Date(paste(ano_pago, mes_pago, "01", sep = "-"), format = "%Y-%m-%d"),
         ano_mes_pago = paste(sprintf("%02d", mes_pago), substr(ano_pago, 3, 4), sep = "-")) %>%
  arrange(fecha) %>%
  mutate(ano_mes_pago = factor(ano_mes_pago, levels = unique(ano_mes_pago))) %>%
  select(-fecha)


```

# Análisis Exploratorio de Datos (EDA)

## Seleccionar variables relevantes

Se seleccionan las variables relevantes para el análisis.
```{r}
permiso_relevante <- permiso %>%
  select(grupo_vehiculo, ano_vehiculo, tipo_de_pago, fecha_pago, ano_pago, mes, mes_pago, ano_mes_pago, valor_neto, valor_ipc, valor_multa, valor_pagado, forma_pago, tipo_vehiculo, marca)
```

## Muestreo

Se realiza un muestreo estratificado para asegurar una representación adecuada de cada grupo en los datos.
```{r}

# Calcular la muestra aleatoria según Desviación Estándar
cant <- nrow(permiso_relevante)
sd <- sd(permiso_relevante$valor_pagado)
n <- tam.muestra(alfa = 0.05, epsilon = 1200, s = sd, N = cant)
set.seed(2)
cant <- sample(nrow(permiso_relevante), n)
permiso_muestra <- permiso_relevante[cant, ]

cat("La cantidad de registros de muestra es:", nrow(permiso_muestra))
```

### Distribucion de Pagos por Año y Meses
Se analiza la distribución de pagos de permisos de circulación por año y mes.

```{r}

# Preparar los datos para el gráfico de área
area_data <- permiso_muestra %>%
  group_by(ano_pago, mes) %>%
  summarise(count = n(), .groups = 'drop')

grafico1 <- grafico_histograma(permiso_muestra, "ano_pago")
grafico2 <- grafico_area(area_data, "mes", "count", "ano_pago")

mostrar_graficos(grafico1, grafico2, ncol = 2)

```
La distribución general muestra una tendencia creciente en la cantidad de pagos de un año a otro.
Cabe destacar que por la pandimia, no se realizaron pagos de permisos de circulación durante los años 2020 - 2021.

Como era de esperar, existe  un fuerte patrón estacional en los pagos de permisos de circulación, con la mayoría de los pagos concentrados en los primeros meses del año, particularmente en marzo y abril.

### Variable: Grupo Vehículo.

Se crean gráficos para analizar la distribución de pagos por tipo de vehículo.
```{r}

# Crear gráficos individuales
grafico1 <- grafico_anillo(permiso_muestra,"grupo_vehiculo")
grafico2 <- grafico_barras(permiso_muestra,"tipo_vehiculo")

# Mostrar los gráficos juntos
mostrar_graficos(grafico1, grafico2, ncol = 2)


```

El 90% de los permisos de circulación son pagados por vehiculos livianos,concentrándose, en su mayoría, en Automóvil y Camioneta.



### Valor Pago por Categoria 

```{r}
vehiculo_liviano_dataset <- permiso_muestra %>% filter(`grupo_vehiculo` == "Vehiculo Liviano")
transporte_publico_dataset <- permiso_muestra %>% filter(`grupo_vehiculo` == "Transporte Publico")
carga_dataset <- permiso_muestra %>% filter(`grupo_vehiculo` == "Carga")


# Crear gráficos individuales
grafico1 <- grafico_boxplot(vehiculo_liviano_dataset, "valor_pagado","Vehiculo Liviano")
grafico2 <- grafico_boxplot(transporte_publico_dataset, "valor_pagado","Transporte Publico")
grafico3 <- grafico_boxplot(carga_dataset, "valor_pagado","Carga")



# Mostrar los gráficos juntos
mostrar_graficos(grafico1, grafico2,grafico3, ncol = 3)



```


### BoxPlot por tipo de Vehiculo

```{r}

grafico1 <- grafico_barras(vehiculo_liviano_dataset,"tipo_vehiculo")
grafico2 <- grafico_boxplot_dos_var(vehiculo_liviano_dataset, "tipo_vehiculo","valor_pagado")



# Mostrar los gráficos juntos
mostrar_graficos(grafico1, grafico2, ncol = 2)



```
## Selecionar Dataset de Automoviles y Camionetas

Debido a que concentran gran parte de los permisos de circulación que son pagados, en análisis se centrará en Automoviles y Camionetas.

```{r}
vehiculo_dataset <- vehiculo_liviano_dataset %>% 
  filter(tipo_vehiculo == "Automovil" | tipo_vehiculo == "Camioneta")

grafico_anillo(vehiculo_dataset,"tipo_vehiculo")

```


## Tratamiento de Outliers
Se identifican y eliminan outliers de los datos para asegurar un análisis más preciso.
```{r}

automovil_dataset <- vehiculo_liviano_dataset %>% 
  filter(tipo_vehiculo == "Automovil")

camioneta_dataset <- vehiculo_liviano_dataset %>% 
  filter(tipo_vehiculo == "Camioneta")

resultado1 <- eliminar_outliers(automovil_dataset, "valor_pagado")
resultado2 <- eliminar_outliers(camioneta_dataset, "valor_pagado")

dataset_sin_outliers1 <- resultado1$dataset_sin_outliers
dataset_sin_outliers2 <- resultado2$dataset_sin_outliers


vehiculo_sin_outliers <- bind_rows(dataset_sin_outliers1, dataset_sin_outliers2)



cat("Número de registros originales:", nrow(vehiculo_dataset), "\n")
cat("Número de registros sin outliers:", nrow(vehiculo_sin_outliers), "\n")

vehiculo_dataset<- vehiculo_sin_outliers
```

## Boxplot por tipo de vehiculo

```{r}
automovil_dataset <- vehiculo_dataset %>% filter(`tipo_vehiculo` == "Automovil")
camioneta_dataset <- vehiculo_dataset %>% filter(`tipo_vehiculo` == "Camioneta")

# Crear gráficos individuales
grafico1 <- grafico_boxplot(automovil_dataset, "valor_pagado","Automovil")
grafico2 <- grafico_boxplot(camioneta_dataset, "valor_pagado","Camioneta")



# Mostrar los gráficos juntos
mostrar_graficos(grafico1, grafico2, ncol = 2)
```


## Matriz de correlacion
Se analiza la correlación entre las variables del conjunto de datos.
```{r}
# Crear gráficos individuales
grafico1 <- grafico_matriz_correlacion( vehiculo_dataset)
grafico2 <- grafico_dispersion(vehiculo_dataset, "ano_vehiculo","valor_pagado")

# Mostrar los gráficos juntos
mostrar_graficos(grafico1, grafico2, ncol = 2)


```

## Distribución de Pagos en Grupos de Vehículos por Meses Relativos
Se genera un resumen de las variables normalizadas utilizando summarytools.
```{r}
# Filtrar y transformar los datos

vehiculo_dataset <- vehiculo_dataset %>%
  arrange(fecha_pago) %>%
  group_by(tipo_vehiculo) %>%
  mutate(
    fecha_relativa = as.yearmon(fecha_pago),
    mes_relativo = as.integer((min(fecha_relativa) - fecha_relativa) * 12)*-1
  ) %>%
  ungroup()

# Resumir los datos por mes relativo y grupo de vehículo
pagos_por_mes_relativo <- vehiculo_dataset %>%
  group_by(tipo_vehiculo, mes_relativo) %>%
  summarise(Cantidad_Pagos = n(), .groups = 'drop')

grafico_lineas(pagos_por_mes_relativo, "mes_relativo", "Cantidad_Pagos", "tipo_vehiculo")

```
Se observa una tendencia proporcionada entre ambos tipos de vehículos, donde ambos tienen un comportamiento similar.

## Valores Nulos y reemplazar por la Mediana

En caso que se encuentren valores, se reemplazan por el valor de la mediana de cada variable.

```{r}
#Imputar valores nulos por la mediana
vehiculo_dataset <- vehiculo_dataset %>%
  mutate(across(everything(), reemplazar_por_mediana))
```

## Descripcion de Variables normalizadas

```{r}
# Obtener un resumen de los datos utilizando summarytools y renderizar en HTML
dfSummary(vehiculo_dataset) %>%
  print(method = 'render')
```

# 4. Modelado de Datos

Aplicación de técnicas de modelado de datos y algoritmos de aprendizaje automático para estimar la cantidad de permisos que se pagarán en los próximos 6 meses por grupo y tipo de vehículo.

## Técnicas y Algoritmos

### 1. Selección del Modelo

Se selecciona el modelo XGBoost para estimar la cantidad de permisos que se pagarán en los próximos 6 meses por grupo y tipo de vehículo.

### 2. Entrenamiento y Evaluación

Se entrena el modelo XGBoost con los datos y se evalúa su rendimiento utilizando métricas como RMSE y R2.
est
### Seleccionar los datos

```{r}

# Configurar semilla para reproducibilidad
set.seed(123)

# Filtrar los datos hasta el año 2018
dataset_modelo <- vehiculo_dataset %>%
  filter(ano_pago <= 2018)

# Definir el tamaño de la muestra por cada categoría de tipo_vehiculo
tamano_muestra <- min(dataset_modelo %>% count(tipo_vehiculo) %>% pull(n))

# Muestreo estratificado para asegurar la misma cantidad de datos por categoría
dataset_modelo <- dataset_modelo %>%
  group_by(tipo_vehiculo) %>%
  sample_n(tamano_muestra) %>%
  ungroup()

grafico_torta(dataset_modelo, "tipo_vehiculo")


```

### Seleccionar Datos

```{r}

# Calcular el mes relativo
dataset_modelo <- dataset_modelo %>%
  arrange(fecha_pago) %>%
  group_by(tipo_vehiculo) %>%
  mutate(
    fecha_relativa = as.yearmon(fecha_pago),
    mes_relativo = as.integer((min(fecha_relativa) - fecha_relativa) * 12)*-1
  ) %>%
  ungroup()

# Crear la variable de cantidad de permisos por grupo de vehículo
cantidad_permisos <- dataset_modelo %>%
  group_by(tipo_vehiculo, mes_relativo) %>%
  summarise(cantidad_permisos = n(), .groups = 'drop')

# Preparar datos con todas las variables
datos_completos <- dataset_modelo %>%
  left_join(cantidad_permisos, by = c("tipo_vehiculo", "mes_relativo"))

# Convertir variables categóricas a factores
datos_completos <- datos_completos %>%
  mutate_if(is.character, as.factor)

# Dividir los datos en conjuntos de entrenamiento (80%) y prueba (20%)
set.seed(1234)
trainIndex <- createDataPartition(datos_completos$cantidad_permisos, p = .8, 
                                  list = FALSE, 
                                  times = 1)
permisoTrain <- datos_completos[trainIndex,]
permisoTest  <- datos_completos[-trainIndex,]

# Asegurar que los niveles de las variables categóricas sean consistentes entre entrenamiento y prueba
permisoTest <- permisoTest %>%
  mutate(across(where(is.factor), ~ factor(.x, levels = levels(permisoTrain[[cur_column()]]))))

# Convertir variables categóricas a indicadores binarios (dummies)
permisoTrain_matrix <- model.matrix(~ . - 1, data = permisoTrain %>% select(-cantidad_permisos))
permisoTest_matrix <- model.matrix(~ . - 1, data = permisoTest %>% select(-cantidad_permisos))

# Crear DMatrix para XGBoost
dtrain_cantidad <- xgb.DMatrix(data = permisoTrain_matrix, label = permisoTrain$cantidad_permisos)
dtest_cantidad <- xgb.DMatrix(data = permisoTest_matrix, label = permisoTest$cantidad_permisos)

# Definir parámetros para el modelo XGBoost
params <- list(booster = "gbtree", objective = "reg:squarederror", eta = 0.3, max_depth = 6)

# Entrenar el modelo XGBoost
modelo_xgb_cantidad <- xgb.train(params, dtrain_cantidad, nrounds = 100)

# Evaluar el modelo
pred_xgb_cantidad <- predict(modelo_xgb_cantidad, dtest_cantidad)
rmse_xgb_cantidad <- RMSE(pred_xgb_cantidad, permisoTest$cantidad_permisos)
rsq_xgb_cantidad <- R2(pred_xgb_cantidad, permisoTest$cantidad_permisos)

# Mostrar resultados del modelo
resultados_cantidad <- tibble(
  Modelo = "XGBoost",
  RMSE = rmse_xgb_cantidad,
  R2 = rsq_xgb_cantidad
)

print(resultados_cantidad)


```


```{r}

# Predicciones vs. Valores Reales
pred_df <- data.frame(
  Actual = permisoTest$cantidad_permisos,
  Predicted = pred_xgb_cantidad
)

grafico_pred_vs_real <- ggplot(pred_df, aes(x = Actual, y = Predicted)) +
  geom_point(alpha = 0.5) +
  geom_abline(slope = 1, intercept = 0, color = "red") +
  labs(title = "Predicciones vs. Valores Reales", x = "Valores Reales", y = "Predicciones") +
  theme_minimal()


# Residuos
residuals <- pred_df$Actual - pred_df$Predicted

grafico_residuos <- ggplot(pred_df, aes(x = Predicted, y = residuals)) +
  geom_point(alpha = 0.5) +
  geom_hline(yintercept = 0, color = "red") +
  labs(title = "Gráfico de Residuos", x = "Predicciones", y = "Residuos") +
  theme_minimal()



mostrar_graficos(grafico_pred_vs_real, grafico_residuos, ncol = 2)

```
La mayoría de los puntos están alineados a lo largo de la línea roja, lo que indica que las predicciones del modelo son muy precisas.
La mayoría de los residuos están cerca de la línea roja horizontal (residuo = 0), lo que indica que las predicciones son precisas y los errores son pequeños.

```{r}
# Importancia en las variables
importance_matrix <- xgb.importance(feature_names = colnames(permisoTrain_matrix), model = modelo_xgb_cantidad)
xgb.plot.importance(importance_matrix, top_n = 15)
```
La variable "mes^7" es la más influyente, con una importancia mucho mayor que las demás. Esto sugiere que la variación en el mes tiene un impacto significativo en la predicción de la cantidad de permisos.


## 5. Interpretación de Resultados

La evaluación del modelo XGBoost ha arrojado resultados muy positivos, con un RMSE (Root Mean Square Error) de 0.4046614 y un R² de 0.9999835. Estos valores indican que el modelo tiene un desempeño excelente en la predicción de la cantidad de permisos de circulación.

RMSE (Root Mean Square Error): El RMSE es una métrica que mide el error promedio de las predicciones del modelo. Un RMSE de 0.4046614 sugiere que el modelo comete un error muy bajo al predecir la cantidad de permisos, lo cual es un resultado muy favorable.

R² (Coeficiente de Determinación): El R² de 0.9999835 indica que el modelo explica el 99.99835% de la variabilidad en los datos de permisos de circulación. Un R² tan cercano a 1 implica que el modelo tiene una precisión extremadamente alta y que las predicciones están muy bien alineadas con los valores reales.


# Conclusión 

El análisis de los datos de permisos de circulación vehicular en Calbuco mediante el modelo XGBoost ha demostrado ser muy eficaz. 
Los resultados sugieren que el modelo puede predecir con gran precisión la cantidad de permisos que se pagarán en el futuro, lo cual es una herramienta valiosa para la planificación y gestión de recursos en la municipalidad.
